<h1>Header file <code>visitor.hpp</code><a id="visitor.hpp"></a></h1>
<pre><code class="language-cpp">namespace <a href='doc_arithmetic_policy.html#arithmetic_policy.hpp'>type_safe</a>
{
    template &lt;typename Visitor, class ... Optionals&gt;
    'hidden' <a href='doc_visitor.html#ts::visit(Visitor&&,Optionals&&...)'>visit</a>(Visitor&amp;&amp; visitor, Optionals&amp;&amp;... optionals);
    
    template &lt;class Visitor, class ... Variants, typename = typename std::enable_if&lt;detail::all_of&lt;detail::is_variant&lt;Variants&gt;::value...&gt;::value&gt;::type&gt;
    decltype(detail::visit_variant(std::forward&lt;Visitor&gt;(visitor), std::forward&lt;Variants&gt;(variants)...)) <a href='doc_visitor.html#ts::visit(Visitor&&,Variants&&...)'>visit</a>(Visitor&amp;&amp; visitor, Variants&amp;&amp;... variants);
}</code></pre>
<h2>Function template <code>type_safe::visit</code> [optional]<a id="ts::visit(Visitor&&,Optionals&&...)"></a></h2>
<pre><code class="language-cpp">template &lt;typename Visitor, class ... Optionals&gt;
'hidden' visit(Visitor&amp;&amp; visitor, Optionals&amp;&amp;... optionals);</code></pre>
<p>Visits a <a href="doc_optional.html#ts::basic_optional-StoragePolicy-">ts::basic_optional</a>.</p>
<p><em>Effects</em>: Effectively calls <code>visitor((optionals.has_value() ? optionals.value() : nullopt)...)</code>, i.e. the <code>operator()</code> of <code>visitor</code> passing it <code>sizeof...(Optionals)</code> arguments, where the <code>i</code>th argument is the <code>value()</code> of the <code>i</code>th optional or <code>nullopt</code>, if it has none. If the particular combination of types is not overloaded, the program is ill-formed, unless the <code>Visitor</code> provides a member named <code>incomplete_visitor</code>, then <code>visit()</code> does not do anything instead of the error.</p>
<p><em>Returns</em>: The result of the chosen <code>operator()</code>, its the type is the common type of all possible combinations.</p>
<h2>Function template <code>type_safe::visit</code><a id="ts::visit(Visitor&&,Variants&&...)"></a></h2>
<pre><code class="language-cpp">template &lt;class Visitor, class ... Variants, typename = typename std::enable_if&lt;detail::all_of&lt;detail::is_variant&lt;Variants&gt;::value...&gt;::value&gt;::type&gt;
decltype(detail::visit_variant(std::forward&lt;Visitor&gt;(visitor), std::forward&lt;Variants&gt;(variants)...)) visit(Visitor&amp;&amp; visitor, Variants&amp;&amp;... variants);</code></pre>
<p>Visits a <a href="doc_variant.html#ts::basic_variant-VariantPolicy,HeadT,TailT...-">ts::basic_variant</a>.</p>
<p><em>Effects</em>: Effectively calls <code>visitor(variants.value(variant_type&lt;Ts&gt;{})...)</code>, where <code>Ts...</code> are the types of the currently active element in the variant, i.e. it calls the <code>operator()</code> of the <code>visitor</code> where the <code>i</code>th argument is the currently stored value in the <code>i</code>th variant, perfectly forwarded. If the <code>i</code>th variant is empty and it allows the empty state, it passes <code>nullvar</code> as parameter, otherwise the behavior is undefined. If the particular combination of types is not overloaded, the program is ill-formed, unless the <code>Visitor</code> provides a member named <code>incomplete_visitor</code>, then <code>visit()</code> does not do anything instead of the error. \returns The result of the chosen <code>operator()</code>, its the type is the common type of all possible combinations. \exclude return \module variant</p>
<hr />


<hr class="footer"/><address class="footer"><small>
Documentation generated by <a target="_blank" href="https://github.com/foonathan/standardese">standardese</a>.
</small></address>
